<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: swap.swaps/UsdtSwap.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: swap.swaps/UsdtSwap.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import debug from 'debug'
import SwapApp, { SwapInterface, constants } from 'swap.app'

const FEE_VALUE = 2000 // satoshis TODO how to get this value
const DUST = 546

const createOmniScript = require('./usdt/omni_script')
const createScript = require('./usdt/swap_script')
const createFundingTransaction = require('./usdt/funding_tx')

class UsdtSwap extends SwapInterface {

  /**
   *
   * @param options
   * @param options.fetchBalance
   * @param options.fetchUnspents
   * @param options.broadcastTx
   */
  constructor(options) {
    super()

    if (typeof options.fetchBalance !== 'function') {
      throw new Error('UsdtSwap: "fetchBalance" required')
    }
    if (typeof options.fetchUnspents !== 'function') {
      throw new Error('UsdtSwap: "fetchUnspents" required')
    }
    if (typeof options.broadcastTx !== 'function') {
      throw new Error('UsdtSwap: "broadcastTx" required')
    }

    this._swapName      = constants.COINS.usdt
    this.fetchBalance   = options.fetchBalance
    this.fetchUnspents  = options.fetchUnspents
    this.broadcastTx    = options.broadcastTx
    this.fetchTx        = options.fetchTx

    this.getRecommendedFees = options.getRecommendedFees || (() => {})
  }

  _initSwap() {
    this.network = (
      SwapApp.isMainNet()
        ? SwapApp.env.bitcoin.networks.bitcoin
        : SwapApp.env.bitcoin.networks.testnet
    )

    if (!SwapApp.isMainNet()) {
      throw new Error(`Sorry, USDT does not yet works on testnet!`)
    }
  }

  /**
   *
   * @param {object} data
   * @param {object} data.script
   * @param {*} data.txRaw
   * @param {string} data.secret
   * @private
   */
  _signTransaction(data, inputIndex = 0) {
    const { script, txRaw, secret } = data

    const hashType      = SwapApp.env.bitcoin.Transaction.SIGHASH_ALL
    const signatureHash = txRaw.hashForSignature(inputIndex, script, hashType)
    const signature     = SwapApp.services.auth.accounts.btc.sign(signatureHash).toScriptSignature(hashType)

    const scriptSig = SwapApp.env.bitcoin.script.scriptHash.input.encode(
      [
        signature,
        SwapApp.services.auth.accounts.btc.getPublicKeyBuffer(),
        Buffer.from(secret.replace(/^0x/, ''), 'hex'),
      ],
      script,
    )

    txRaw.setInputScript(inputIndex, scriptSig)
  }

  /**
   *
   * @param {object} data
   * @param {string} data.secretHash
   * @param {string} data.ownerPublicKey
   * @param {string} data.recipientPublicKey
   * @param {number} data.lockTime
   * @returns {{scriptAddress: *, script: (*|{ignored})}}
   */
  createScript(data) {
    const { secretHash, ownerPublicKey, recipientPublicKey, lockTime } = data

    debug('swap.core:swaps')('DATA', data)

    const script = SwapApp.env.bitcoin.script.compile([

      SwapApp.env.bitcoin.opcodes.OP_RIPEMD160,
      Buffer.from(secretHash, 'hex'),
      SwapApp.env.bitcoin.opcodes.OP_EQUALVERIFY,

      Buffer.from(recipientPublicKey, 'hex'),
      SwapApp.env.bitcoin.opcodes.OP_EQUAL,
      SwapApp.env.bitcoin.opcodes.OP_IF,

      Buffer.from(recipientPublicKey, 'hex'),
      SwapApp.env.bitcoin.opcodes.OP_CHECKSIG,

      SwapApp.env.bitcoin.opcodes.OP_ELSE,

      SwapApp.env.bitcoin.script.number.encode(lockTime),
      SwapApp.env.bitcoin.opcodes.OP_CHECKLOCKTIMEVERIFY,
      SwapApp.env.bitcoin.opcodes.OP_DROP,
      Buffer.from(ownerPublicKey, 'hex'),
      SwapApp.env.bitcoin.opcodes.OP_CHECKSIG,

      SwapApp.env.bitcoin.opcodes.OP_ENDIF,
    ])

    const scriptPubKey  = SwapApp.env.bitcoin.script.scriptHash.output.encode(SwapApp.env.bitcoin.crypto.hash160(script))
    const scriptAddress = SwapApp.env.bitcoin.address.fromOutputScript(scriptPubKey, this.network)

    return {
      scriptAddress,
      script,
    }
  }

  /**
   *
   * @param {object} data
   * @param {string} data.recipientPublicKey
   * @param {number} data.lockTime
   * @param {object} expected
   * @param {number} expected.value
   * @param {number} expected.lockTime
   * @param {string} expected.recipientPublicKey
   * @returns {Promise.&lt;string>}
   */
  async checkScript(data, expected) {
    const { scriptValues, fundingTxHash } = data

    const { secretHash, ownerPublicKey, recipientPublicKey, lockTime } = scriptValues
    const { scriptAddress, script } = createScript(secretHash, ownerPublicKey, recipientPublicKey, lockTime)

    const unspents = await this.fetchUnspents(scriptAddress)
    const totalUnspent  = unspents.reduce((summ, { satoshis }) => summ + satoshis, 0)
    const expectedValue = 546

    if (expectedValue > totalUnspent) {
      return `Expected script value: ${expectedValue}, got: ${totalUnspent}. Maybe the script was not mined?`
    }

    let outputs
    try {
      const tx = await this.fetchTx(fundingTxHash)

      outputs = tx.vout
    } catch (err) {
      console.error(err)
      return `Can't get funding tx outputs ${fundingTxHash}`
    }
    debug('swap.core:swaps')(outputs)

    if (!outputs || outputs.length &lt; 2) {
      return `Expected at least 2 outputs at funding tx ${fundingTxHash}, got: ${outputs}`
    }

    // check output-0 is script with same address
    const htlcScriptOutput = outputs[0]
    try {
      const fundedScriptAddress = htlcScriptOutput.scriptPubKey.addresses[0]

      if (scriptAddress !== fundedScriptAddress) {
        return `Expected script address: ${scriptAddress}, got: ${fundedScriptAddress}`
      }
    } catch (err) {
      console.error(err)
      return `Expected script address: ${scriptAddress}, got error at ${htlcScriptOutput}`
    }

    // check output-1 is a OMNI
    const omniOutput = outputs[1]
    try {
      const omniScript = omniOutput.scriptPubKey.asm
      const expectedOmniScript = createOmniScript(expected.amount)
      const expectedOmniOutput = SwapApp.env.bitcoin.script.toASM(expectedOmniScript)

      if (expectedOmniOutput !== omniScript) {
        debug('swap.core:swaps')(expectedOmniOutput, omniScript)
        return `Expected first output value: `
        + expectedOmniOutput
        + `, got: `
        + omniScript
      }
    } catch (err) {
      console.error(err)
      return `Expected omni output for amount = ${expected.amount}, got error at ${omniOutput}`
    }

    if (expected.lockTime > lockTime) {
      return `Expected script lockTime: ${expected.lockTime}, got: ${lockTime}`
    }
    if (expected.recipientPublicKey !== recipientPublicKey) {
      return `Expected script recipient publicKey: ${expected.recipientPublicKey}, got: ${recipientPublicKey}`
    }
  }

  /**
   *
   * @param {object} data
   * @param {object} data.scriptValues
   * @param {BigNumber} data.amount
   * @param {function} handleTransactionHash
   * @returns {Promise}
   */
   fundScript(data, handleTransactionHash) {
    const { scriptValues, amount } = data

    return new Promise(async (resolve, reject) => {
      try {
        const { ownerPublicKey, recipientPublicKey } = scriptValues

        const dialog = {
          owner: SwapApp.services.auth.accounts.btc,
          party: Buffer.from(recipientPublicKey, 'hex')
        }

        const funding = await createFundingTransaction(amount, dialog, scriptValues, this.fetchUnspents, this.network)

        if (typeof handleTransactionHash === 'function') {
          const txRaw = funding.tx.buildIncomplete()
          handleTransactionHash(txRaw.getId(), funding)
        }

        try {
          const result = await this.broadcastTx(funding.hex)

          resolve(result)
        }
        catch (err) {
          reject(err)
        }
      }
      catch (err) {
        reject(err)
      }
    })
  }

  redeemScript(data, handleTransactionHash, isRefund) {
    const { amount, scriptValues, secret } = data

    return new Promise(async (resolve, reject) => {
      try {
        const { secretHash, lockTime } = scriptValues
        const { ownerPublicKey, recipientPublicKey } = scriptValues


        const redeem_tx = new SwapApp.env.bitcoin.TransactionBuilder(this.network)

        const { script, scriptAddress } = createScript(
          secretHash,
          ownerPublicKey,
          recipientPublicKey,
          lockTime)

        debug('swap.core:swaps')('script address', scriptAddress)
        const keyPair = SwapApp.services.auth.accounts.btc
        const myBtcAddress = keyPair.getAddress()

        const myUnspents      = await this.fetchUnspents(myBtcAddress)
        const scriptUnspents  = await this.fetchUnspents(scriptAddress)


        const unspents  = [ ...scriptUnspents, ...myUnspents ]
        debug('swap.core:swaps')('unspents', unspents)
        const fundValue = DUST
        const feeValue  = 5000

        const totalUnspent  = unspents.reduce((summ, { satoshis }) => summ + satoshis, 0)
        const totalValue    = totalUnspent - feeValue - fundValue

        if (totalUnspent &lt; feeValue + fundValue) {
          throw new Error(`Total less than fee: ${totalUnspent} &lt; ${fundValue} + ${feeValue}`)
        }

        if (isRefund) {
          redeem_tx.setLockTime(lockTime)
        }

        scriptUnspents.forEach(({ txid, vout }) => {
          redeem_tx.addInput(txid, vout, 0xfffffffe)
        })

        myUnspents.forEach(({ txid, vout }, index) => {
          redeem_tx.addInput(txid, vout)
        })

        const omniOutput = createOmniScript(amount)

        redeem_tx.addOutput(myBtcAddress, fundValue)
        redeem_tx.addOutput(myBtcAddress, totalValue)
        redeem_tx.addOutput(omniOutput, 0)

        myUnspents.forEach((utxo, index) => {
          const inputIndex = index + scriptUnspents.length
          redeem_tx.sign(inputIndex, keyPair)
        })

        const txRaw = redeem_tx.buildIncomplete()

        const forSigning = {
          txRaw,
          script,
          secret,
        }

        this._signTransaction(forSigning, 0)

        const tx = txRaw

        debug('swap.core:swaps')('redeem tx hash', tx.getId())
        debug('swap.core:swaps')(`redeem tx hex ${tx.toHex()}`)

        if (typeof handleTransactionHash === 'function') {
          handleTransactionHash(tx.getId())
        }

        try {
          const result = await this.broadcastTx(tx.toHex())

          resolve(result)
        }
        catch (err) {
          reject(err)
        }
      }
      catch (err) {
        reject(err)
      }
    })
  }

  /**
   *
   * @param {object|string} data - scriptValues or wallet address
   * @returns {Promise.&lt;void>}
   */
  async getBalance(data) {
    let address

    if (typeof data === 'string') {
      address = data
    }
    else if (typeof data === 'object') {
      const { scriptAddress } = this.createScript(data)

      address = scriptAddress
    }
    else {
      throw new Error('Wrong data type')
    }

    const unspents      = await this.fetchUnspents(address)
    const totalUnspent  = unspents &amp;&amp; unspents.length &amp;&amp; unspents.reduce((summ, { satoshis }) => summ + satoshis, 0) || 0

    return totalUnspent
  }

  /**
   *
   * @param {object} data
   * @param {object} data.scriptValues
   * @param {string} data.secret
   * @param {function} handleTransactionHash
   * @param {boolean} isRefund
   * @returns {Promise}
   */
  withdraw(data, handleTransactionHash) {
    return this.redeemScript(data, handleTransactionHash, false)
  }

  /**
   *
   * @param {object} data
   * @param {object} data.scriptValues
   * @param {string} data.secret
   * @param {function} handleTransactionHash
   * @returns {Promise}
   */
  refund(data, handleTransactionHash) {
    return this.redeemScript(data, handleTransactionHash, true)
  }
}


export default UsdtSwap
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BtcSwap.html">BtcSwap</a></li><li><a href="EthSwap.html">EthSwap</a></li><li><a href="EthTokenSwap.html">EthTokenSwap</a></li><li><a href="Event.html">Event</a></li><li><a href="LtcSwap.html">LtcSwap</a></li><li><a href="Order.html">Order</a></li><li><a href="UsdtSwap.html">UsdtSwap</a></li></ul><h3>Global</h3><ul><li><a href="global.html#createScript">createScript</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Dec 18 2018 16:19:29 GMT+0300 (Moscow Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
